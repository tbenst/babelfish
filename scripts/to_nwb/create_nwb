#!/usr/bin/env python
__doc__ = """Convert TIFF_PATHS to .ty.h5 imaging (TxCxZxHxW)"""

#%%
import sys
from functools import partial
from typing import List

import tifffile, click, re, os
from tqdm import tqdm
import numpy as np
from babelfish.helpers import resize_3d, resize_4d, compression_opts, \
    resize_from_tiff, read_tiff_path, assign_tiff_Z_to_dset, \
    assign_stack_to_dset, sort_by_z_plane

from hdf5plugin import Blosc
from datetime import datetime
from dateutil.tz import tzlocal
from hdmf.backends.hdf5.h5_utils import H5DataIO
from pynwb import NWBFile, TimeSeries, NWBHDF5IO
from pynwb.ophys import TwoPhotonSeries, OpticalChannel, ImageSegmentation, Fluorescence
from pynwb.device import Device
from pynwb.image import ImageSeries
# %%



def add_series_to_nwb(ctx, dataset_name: str, imaging_rate: float,
              two_p: bool, grid_spacing,
              T:int, Z:int, H:int, W:int, excitation_lambda=920.,
              indicator='HuC:H2B-GCaMP6S',
              imaging_plane_description="",
              device = Device("Olympus 2P"),
              optical_channel = OpticalChannel('green',
                'old PMT, wavelength is approximate.', 510.),
              compression_level=3
              ):
    """
    Add an (empty) Image or 2P timeseries to the nwbfile handle.
    """
    ctx.obj['nwbfile'].add_device(device)
    
    imaging_plane = ctx.obj['nwbfile'].create_imaging_plane('zebrafish_brain', optical_channel,
        description='', device=device, excitation_lambda=excitation_lambda,
        imaging_rate=np.nan, indicator=indicator, location='',
        grid_spacing=grid_spacing, grid_spacing_unit='microns')
    Blosc('zstd', 3)
    twoP_data = H5DataIO(data=np.empty(shape=(T, Z, H, W), dtype='float'),
                              chunks=(1, Z, H, W),
                              fillvalue=np.nan,
                              **Blosc('zstd', compression_level)
                              )
    if two_p:
        image_series = TwoPhotonSeries(name=dataset_name, data=twoP_data,
            rate=imaging_rate, imaging_plane=imaging_plane)
    else:
        image_series = ImageSeries(name=dataset_name, data=twoP_data,
            rate=imaging_rate, imaging_plane=imaging_plane)
    
    ctx.obj['nwbfile'].add_acquisition(image_series)
    ctx.obj['io'].write(ctx.obj['nwbfile'])


CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])
@click.group(chain=True)
@click.pass_context
@click.argument("tiff_paths", type=click.Path(exists=True), nargs=-1)
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option("-s", "--start-time", default='', type=str)
@click.option("-o", "--output", type=click.Path(exists=False),
              help="a .nwb file")
@click.option("-c", "--compression-level", default=3, help="compression for zstd")
@click.option('-e', '--experimenter', default='')
@click.option('-i', '--institution', default="Stanford University")
@click.option('-l', '--lab', default="Deisseroth Lab")
def main(ctx, tiff_paths, start_time:str, output:str, compression_level:int,
                  experimenter:str, institution:str, lab:str):
    """Create a Neurodata without borders (NWB) file.
        START_TIME: ISO datetime like 2020-04-09T17:02:01.234
    Supports chaining multiple commands.
    
    Convert TIFF_PATHS to NWB file with imaging dataset (TxZxHxW)
    
    Each tiff should be a separate time step.
    """
    if output_path is None:
        name, _ = os.path.splitext(tiff_paths[0])
        name, _ = os.path.splitext(name) # handle two extensions
        output_path = name + ".nwb"

    if os.path.exists(output_path):
        mode = click.prompt(
            f'{output_path} exists.\nOverwrite, append or cancel? (w,a,c):',
                             default='w')
        if mode=='c':
            exit(0)
    else:
        mode = 'w'
    
    if os.path.exists(output_path):
        mode = click.prompt(
            f'{output_path} exists.\nOverwrite, append or cancel? (w,a,c):',
                             default='a')
        if mode=='c':
            exit(0)
    else:
        mode = 'w'

    # ensure that ctx.obj exists and is a dict (in case `cli()` is called
    # by means other than the `if __main__` block below)
    ctx.ensure_object(dict)
    ctx.obj['compression_level'] = compression_level
    ctx.obj['io'] = NWBHDF5IO(output, mode)
    
    if mode=='a':
        ctx.obj['nwbfile'] = ctx.obj['io'].read()
    elif mode=='w':
        try:
            assert not start_time==''
        except ValueError:
            print("Please specify a start time using ISO date format, e.g. " \
                  '-s "2020-04-09T17:02:01.234"')
            exit(1)
        ctx.obj['nwbfile'] = NWBFile('demonstrate NWBFile basics',
                        'NWB123',
                        start_time,
                        experimenter=experimenter,
                        institution=institution,
                        lab=lab)
        
    

# @main.command()
# @click.pass_context
@click.argument("tiff_paths", type=click.Path(exists=True), nargs=-1)
@click.option("-n", "--name", type=float,
              help="name for the imaging dataset")
@click.option("-2", "--two-p/--no-two-p", default=False,
              help="whether dataset is a Two Photon series")
@click.option("-r", "--frame-rate", type=float, help="Hz")
@click.option("-x", "--um-per-x", type=float)
@click.option("-y", "--um-per-y", type=float)
@click.option("-z", "--um-per-z", type=float)
@click.option("-ex", "--excitation", type=float,
              help="excitation wavelength (nm)")
@click.option("-em", "--emission", type=float,
              help="emission wavelength (nm)")
@click.option("-i", "--indicator", type=str, default='HuC:H2B-GCaMP6S',
              help="emission wavelength (nm)")
@click.option("--ochannel-desc", type=str, default='',
              help="Optical channel description")
@click.option("--plane_description", type=str, default='',
              help="Imaging plane description")
@click.option("-d", "--device", type=str, default='',
              help="name of imaging microscope / device")
def from_tiff_Z(ctx, tiff_paths: List,
                frame_rate:float,  device:str,
                  um_per_x:float, um_per_y:float, um_per_z:float,
                  name:str, two_p:bool, indicator:str, ochannel_desc:str,
                  plane_description:str, emission:float, excitation:float,):
    """Add an imaging dataset from per Z-plane tiff files.
    

    TIFF_PATHS: one or more file paths of 3D/4D tiffs. Must be (ZxWxH) or (CxZxWxH)
    """
    
    if len(tiff_paths)==0:
        # print help and exit
        # ctx = click.get_current_context()
        click.echo(ctx.get_help())
        exit(1)

    tiff_paths = sort_by_z_plane(tiff_paths)
    Z = len(tiff_paths)
    assert Z > 0

    tiff = read_tiff_path(tiff_paths[0])
    tiff_shape = tiff.series[0].shape
    tiff_dtype = tiff.pages[0].dtype
    print("SHAPE", tiff_shape)
    if len(tiff_shape)==3:
        T, H, W = tiff_shape
        C = 1
    elif len(tiff_shape)==4:
        raise(NotImplementedError("no support for 4D tiffs yet"))
        # switch to T x C?
        C, T, H, W = tiff_shape
    else:
        raise(NotImplementedError(f"bad tiff ndims of {len(tiff_shape)}"))

    optical_channel = OpticalChannel(f"{emission} nm",
                ochannel_desc, emission)
    add_series_to_nwb(ctx, name, frame_rate,
        excitation_lambda=excitation, indicator=indicator,
        imaging_plane_description=plane_description,
        device=Device(device), optical_channel=optical_channel,
        T=T, Z=Z, H=H, W=W, two_p=two_p,
        grid_spacing=[um_per_z, um_per_y, um_per_x],
        compression_level=ctx.obj['compression_level']
        )
    
    data = ctx.obj['nwbfile'].get_acquisition(name).data

    assign_tiff_Z_to_dset(data, tiff, Z=0)

    for i, tp in tqdm(enumerate(tiff_paths[1:],1),
                        total=len(tiff_paths[1:])):
        tiff = read_tiff_path(tp)
        assign_tiff_Z_to_dset(data, tiff, Z=i)
    

# @main.resultcallback()
# @click.pass_context
def save_nwb(ctx):
    ctx.obj['io'].write(ctx.obj['nwbfile'])
    ctx.obj['io'].close()
    print("Finished")
    
if __name__ == '__main__':
    main(obj={})
