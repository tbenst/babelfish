#!/usr/bin/env bash
"true" '''\'
exec nix-shell "$(dirname ${BASH_SOURCE[0]})/../shell.nix" --run "$(printf '%q ' python "$0" "$@")"
'''

"""nilogger_binary_log_parser.py: Functions to parse and process simple binary log files containing digitized streams of analog inputs to nidaq.  Binary files are created using matlab script nilogger.m.  Streams inlcude Olympus 2p frame time and tail camera frame times."""

__author__      = "Aaron Andalman"
__copyright__   = "Copyright 2014, Stanford University"
__credits__ = ["Aaron Andalman"]
__license__ = "MIT"
__version__ = "0.1.0"

import numpy as np


def parse_stimpy_daq_binary_log(filename, num_channels=3):
        """                                                                                                                                                                                                       
        Parse binary log file generated by nilogger.m                                                                                                                                                              
        As of 2015.10.15:                                                                                                                                                                                         
        Channel 1 is olympus frame times                                                                                                                                                                          
        Channel 2 is tailcam exposure times                                                                                                                                                                       
        Channel 3 is current through tank.                                                                                                                                                                        
        """
        with open(filename,'r') as fid:
                data_array = np.fromfile(fid, np.double).reshape((-1, num_channels)).T
        channels = data_array
        return channels

def parse_matlab_daq_binary_log(filename, num_channels=3):
    """
    Parse binary log file generated by nilogger.m
    As of 2014.10.01:
    Channel 1 is olympus frame times
    Channel 2 is tailcam exposure times
    Channel 3 is current through tank.
    """
    with open(filename,'r') as fid:
        data_array = np.fromfile(fid, np.double).reshape((-1, num_channels+1)).T
    time_s = data_array[0,:]
    channels = data_array[1:,:]
    fs = 1/ np.diff(time_s).mean()
    return time_s, channels, fs

def segment_stimpy_shock_TTL(sig, fs):
    from logfile_parsers.ustim_log_parser import detectThresholdCrossingTimes, detectThresholdCrossings
    
    rise, fall= detectThresholdCrossingTimes(sig, 2.5, bAbove=False, fs=fs)
    rise = np.array(rise)
    fall = np.array(fall)

    assert rise.shape[0] == fall.shape[0]

    #check if last frame is complete:
    if (fall[-1] - rise[-1]) - np.median(fall-rise) > .001:
        print("Warning: removing incomplete final frame.")
        rise = rise[:-1]
        fall = fall[:-1]
    assert rise.shape[0] == fall.shape[0]

    return rise, fall

#todo: modify to accept time array instead of sampling rate
def segment_2p_frametimes(sig, fs, num_zplanes=1, num_frame_avg=1, start_time=None, end_time=None):
    """
    Extract frame start and end times from recording of Olympus analog output.
    If incomplete cycle through zplanes at end of recording, the last cycle is tossed out.

    Inputs:
    sig: olympus signal extracted by parse_matlab_daq_binary_log
    fs: signal sampling rate.
    num_zplanes: number of z-planes being recorded.
    end_time: don't parse frames after this time.
    """

    from ustim_log_parser import detectThresholdCrossingTimes, detectThresholdCrossings

    rise, fall= detectThresholdCrossingTimes(sig, 2.5, bAbove=False, fs=fs)
    rise = np.array(rise)
    fall = np.array(fall)

    #remove frames outside of specified time range
    if end_time is not None:
        rise = rise[rise<end_time]
        fall = fall[fall<end_time]

    if start_time is not None:
        rise = rise[rise>start_time]
        fall = fall[fall>start_time]

    assert rise.shape[0] == fall.shape[0]

    #check if last frame is complete:
    if (fall[-1] - rise[-1]) - np.median(fall-rise) > .001:
        print("Warning: removing incomplete final frame.")
        rise = rise[:-1]
        fall = fall[:-1]

    assert rise.shape[0] == fall.shape[0]
    print(rise[0])
    assert rise[0] > .3 #not yet handling the case where the frames being captured before log begins.

    if rise.shape[0]%(num_zplanes*num_frame_avg) > 0:
        print("Warning: all z-planes do not have same number of frames. Removing excess planes.")
        rise = rise[:-(rise.shape[0]%(num_zplanes*num_frame_avg))]
        fall = fall[:-(fall.shape[0]%(num_zplanes*num_frame_avg))]

    #combine frames times accorning to frame averaging
    rise = rise[::num_frame_avg]
    fall = fall[num_frame_avg-1::num_frame_avg]

    frameDurations = (fall - rise)
    #tndx = np.argmax(np.abs(frameDurations - frameDurations.mean()))
    #print tndx, frameDurations[tndx], rise[tndx]
    assert np.abs(frameDurations - frameDurations.mean()).max() < .001
    frame_starttime = np.array(rise).reshape((-1,num_zplanes))
    frame_endtime = np.array(fall).reshape((-1,num_zplanes))
    if np.abs(np.diff(frame_starttime[:,0]) - np.diff(frame_starttime[:,0]).mean()).max() > .01:
        print("Warning spacing between frames varies by %4.4f"%(np.abs(np.diff(frame_starttime[:,0]) - np.diff(frame_starttime[:,0]).mean()).max()))
    return frame_starttime, frame_endtime

#todo: modify to accept time array instead of sampling rate
def segment_andor_frametimes(sig, fs):
    """
    Extract frame start and end times from recording of andor analog output.
    If incomplete cycle through zplanes at end of recording, the last cycle is tossed out.

    Inputs:
    sig: frame signal extracted by parse_stimpy_daq_binary_log
    fs: signal sampling rate.
    """

    from logfile_parsers.ustim_log_parser import detectThresholdCrossingTimes, detectThresholdCrossings

    rise, fall= detectThresholdCrossingTimes(sig, 2.5, bAbove=True, fs=fs)
    rise = np.array(rise)
    fall = np.array(fall)

    assert rise.shape[0] == fall.shape[0]

    #check if last frame is complete:
    if abs((fall[-1] - rise[-1]) - np.median(fall-rise)) > .001:
        print("Warning: removing incomplete final frame.")
        rise = rise[:-1]
        fall = fall[:-1]

    assert rise.shape[0] == fall.shape[0]
    assert rise[0] > .1 #not yet handling the case where the frames being captured before log begins.

    frameDurations = (fall - rise)
    #tndx = np.argmax(np.abs(frameDurations - frameDurations.mean()))
    #print tndx, frameDurations[tndx], frameDurations.mean(), rise[tndx]
    if np.abs(frameDurations - frameDurations.mean()).max() < .001:
        frame_starttime = np.array(rise)
        frame_endtime = np.array(fall)
    else:
        frame_starttime = np.array(rise)
        frame_endtime = np.array(fall)
        print("You had a frame that failed assertion because of a spacing issue. You should check this before moving forward")
    if np.abs(np.diff(frame_starttime) - np.diff(frame_starttime).mean()).max() > .01:
        print("Warning spacing between frames varies by %4.4f"%(np.abs(np.diff(frame_starttime) - 
                                       np.diff(frame_starttime).mean()).max()))

    return frame_starttime, frame_endtime

#todo: modify to accept time array instead of sampling rate
def segment_tailcam_frametimes(sig, fs):
    """
    Extract tailcam frametime start and end times from recording of camera exposure lineout.

    This function handles a few user error cases which may not be generally applicable.  This logic
    should probably be factored into separate functions. But for now it does the following:

    1) The exposure signal persists even when the camera is simply being previewed rather than recorded.
    Thus if preview is not stopped before starting the experiment, superfluous frames will be logged.
    Fortunately when the camera transitions from preview to record there is slight larger than normal gap
    between frames. Therefore the tailcam frames are present from the very beginning of the log file,
    then frames prior to gap are excluded.

    2) The same problem exists when the experiment is stopped. Therefore function looks for a final gap
    frame intervals, and truncates frames after this gap if it exists.  Note that due to details of
    fishvr3.m, the camera does not transition from record to preview until a few frames after frames
    are no longer saved to disk.  Therefore there may be a few more frame times than actual frames in the
    tail movie.

    Inputs:
    sig: exposure lineout from tail camera.
    fs: signal sampling rate.
    """

    from ustim_log_parser import detectThresholdCrossingTimes, detectThresholdCrossings

    rise, fall= detectThresholdCrossingTimes(sig, 2.5, bAbove=True, fs=fs)
    rise = np.array(rise)
    fall = np.array(fall)
    assert rise.shape[0] == fall.shape[0]
    bFindGap = False
    if rise[0] < .1:
        print("Warning: Camera was running when logging started. Will try to find gap in frametimes.")
        bFindGap = True
    #assert rise[0] > 1 #not yet handling the case where the frames being captured before log begins.
    frameDurations = (fall - rise)
    print('Largest gap', np.abs(frameDurations - frameDurations.mean()).max())
    assert np.abs(frameDurations - frameDurations.mean()).max() < .004

    gapSize = .1
    if bFindGap:
        gaps = np.where(np.diff(rise) > gapSize)[0]
        if len(gaps) == 0:
            raise Exception("Camera running from start and no gap greater than %f s found"%gapSize)
        else:
            print("Found first gap at t=%f. Trunctating prior frames."%rise[gaps[0]])
            rise = rise[gaps[0]+1:]
            fall = fall[gaps[0]+1:]

    gaps = np.where(np.diff(rise) > gapSize)[0]
    if len(gaps)>0:
        print("Trunctating frames after last gap which is presumably when recording stopped t=%f"%rise[gaps[-1]])
        rise = rise[:gaps[-1]]
        fall = fall[:gaps[-1]]

    frame_starttime = rise
    frame_endtime = fall
    if np.abs(np.diff(frame_starttime) - np.diff(frame_starttime).mean()).max() > .01:
        dft = np.abs(np.diff(frame_starttime) - np.diff(frame_starttime).mean()).max()
        t_gap = np.argmax(np.abs(np.diff(frame_starttime) - np.diff(frame_starttime).mean()))
        print("Warning spacing between frames varies by %4.4f.  See t=%f"%(dft,frame_starttime[t_gap]))
    return frame_starttime, frame_endtime
