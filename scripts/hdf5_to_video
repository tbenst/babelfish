#!/usr/bin/env bash
"exec" "$(which nix-shell)" "$(dirname ${BASH_SOURCE[0]})/../shell.nix" "--run" "python $0 $*"

import h5py, click, os, numpy as np
from tqdm import tqdm


CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])

@click.command(context_settings=CONTEXT_SETTINGS)
@click.argument("hdf5_file", type=click.Path(exists=True))
@click.argument("dataset", type=str)
@click.argument("output_path", type=click.Path(exists=False), required=False)
@click.option("-r", "--frame-rate", default=60, type=float, help="Hz")
@click.option('-f', '--pix-format', default='gray8', help="pixel format")
# @click.option('-b', '--bitrate', type=int, default=8000000)
@click.option('-c', '--codec', default='libx265')
@click.option('-q', '--quality', default='22', type=str, help="CRF quality")
@click.option("--av", "lib", flag_value="av", default=True)
@click.option("--moviepy", "lib", flag_value="moviepy")
def hdf5_to_video(hdf5_file: str, dataset: str, quality: str, codec, pix_format,
                          output_path: str, frame_rate: float, lib: float):
    """Convert HDF5_FILE["DATASET"] to [output_path], an .mp4 file.
    
    Dataset must be 3D tensor. Example: 
    ~/code/babelfish/scripts/hdf5_to_video f2_e1_FishVR.mat  "/gROI"
    """
    if hdf5_file is None or dataset is None:
        # print help and exit
        ctx = click.get_current_context()
        click.echo(ctx.get_help())
        exit(0)
    
    if output_path is None:
        name, _ = os.path.splitext(hdf5_file)
        name, _ = os.path.splitext(name)
        output_path = name + ".mp4"
    # scripts/hdf5_to_video /data/dlab/zfish_2p/20191101_6f/f2_e1_FishVR.mat "/gROI" x264 benchmark at 205.88 it/s
    # x265 at 110.8 it/s
    with h5py.File(hdf5_file, 'r', swmr=True) as h5:
        imaging = h5[dataset]
        print(f"found {imaging.shape[0]} frames")
        assert len(imaging.shape)==4
        assert imaging.shape[1]==1 # empty dim
        
        if lib=="av":
            import av
            output = av.open(output_path, 'w')
            stream = output.add_stream(codec, frame_rate)
            # stream.bit_rate = bitrate
            stream.pix_fmt = pix_format
            stream.options = {'crf': quality}

            for array in tqdm(imaging):
                frame = av.VideoFrame.from_ndarray(array[0], format='gray8')
                for packet in stream.encode(frame):
                    output.mux(packet)
            
            # flush to disk
            for packet in stream.encode():
                output.mux(packet)
            output.close()
            
        elif lib=="moviepy":
            import moviepy.editor as mpy
            global c
            c = 0
            print("imaging", imaging.shape)
            def make_frame(t):
                global c
                frame = np.repeat(np.array(imaging[c,0])[:,:,None],3,axis=2)
                c += 1
                return frame 
            fps = 60
            duration = len(imaging)/fps
            clip = mpy.VideoClip(make_frame, duration = duration)

            clip.write_videofile(output_path, fps=fps, codec=codec,
                ffmpeg_params=['-crf', quality])
    
    print("created video at " + output_path)

if __name__ == '__main__':
    hdf5_to_video()